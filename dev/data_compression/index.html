<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Data Compression · LEGEND Data Format Specifications</title><link rel="canonical" href="https://legend-exp.github.io/legend-data-format-specs/stable/data_compression/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>LEGEND Data Format Specifications</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../hdf5/">HDF5</a></li><li class="current"><a class="toctext" href>Data Compression</a><ul class="internal"><li><a class="toctext" href="#Lossless-compression-of-integer-valued-waveform-vectors-1">Lossless compression of integer-valued waveform vectors</a></li></ul></li><li><a class="toctext" href="../daq_data/">DAQ Data</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Data Compression</a></li></ul><a class="edit-page" href="https://github.com/legend-exp/legend-data-format-specs/blob/master/docs/src/data_compression.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Data Compression</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Data-Compression-1" href="#Data-Compression-1">Data Compression</a></h1><p>In addition to compression features provided by standard data formats (HDF5, etc.), LEGEND data uses some custom data compression.</p><p>In the interest of long-term data accessibility and to ensure compliance with FAIR data principles, use of custom data compression methods has to be limited to a minimum number of methods and use cases. Long-term use is only acceptable if:</p><ul><li><p>The custom compression significantly outperforms standard compression methods in compression ratio and/or (de-)compression speed for important use cases.</p></li><li><p>A complete formal description of the algorithms exists and is made publicly available under a license that allows for independent third-party implementations.</p></li><li><p>Verified implementations exist in a least two different programming languages, at least one of which has been implemented independently from the formal description of the algorithm and at least one of which is made publicly available under an open-source license.</p></li></ul><h2><a class="nav-anchor" id="Lossless-compression-of-integer-valued-waveform-vectors-1" href="#Lossless-compression-of-integer-valued-waveform-vectors-1">Lossless compression of integer-valued waveform vectors</a></h2><p>As detector waveforms have specific shapes, custom compression algorithms optimized for this use case can show a much higher speed/throughput than generic compression algorithms, at similar compression ratios.</p><p>Currently, we use the following custom integer-waveform compression algorithms:</p><ul><li>radware-sigcompress v1.0</li></ul><p>Other compression algorithms are being developed, tested and evaluated.</p><p>Note: The algorithm(s) in use are still subject to change, long-term data compatibility is not guaranteed at this point.</p><h3><a class="nav-anchor" id="radware-sigcompress-1" href="#radware-sigcompress-1">radware-sigcompress</a></h3><p>There is no formal description of the radware-sigcompress algorithm yet, so the C-code of the original implementation (&quot;sigcompress.c&quot;) will serve as the reference for now:</p><pre><code class="language-C">// radware-sigcompress, v1.0
//
// This code is licensed under the MIT License (MIT).
// Copyright (c) 2018, David C. Radford &lt;radforddc@ornl.gov&gt;

int compress_signal(short *sig_in, unsigned short *sig_out, int sig_len_in) {

  int   i, j, max1, max2, min1, min2, ds, nb1, nb2;
  int   iso, nw, bp, dd1, dd2;
  unsigned short db[2];
  unsigned int   *dd = (unsigned int *) db;
  static unsigned short mask[17] = {0, 1,3,7,15, 31,63,127,255,
                                    511,1023,2047,4095, 8191,16383,32767,65535};

  //static int len[17] = {4096, 2048,512,256,128, 128,128,128,128,
  //                      128,128,128,128, 48,48,48,48};
  /* ------------ do compression of signal ------------ */
  j = iso = bp = 0;

  sig_out[iso++] = sig_len_in;     // signal length
  while (j &lt; sig_len_in) {         // j = starting index of section of signal
    // find optimal method and length for compression of next section of signal 
    max1 = min1 = sig_in[j];
    max2 = -16000;
    min2 = 16000;
    nb1 = nb2 = 2;
    nw = 1;
    for (i=j+1; i &lt; sig_len_in &amp;&amp; i &lt; j+48; i++) { // FIXME; # 48 could be tuned better?
      if (max1 &lt; sig_in[i]) max1 = sig_in[i];
      if (min1 &gt; sig_in[i]) min1 = sig_in[i];
      ds = sig_in[i] - sig_in[i-1];
      if (max2 &lt; ds) max2 = ds;
      if (min2 &gt; ds) min2 = ds;
        nw++;
    }
    if (max1-min1 &lt;= max2-min2) { // use absolute values
      nb2 = 99;
      while (max1 - min1 &gt; mask[nb1]) nb1++;
      //for (; i &lt; sig_len_in &amp;&amp; i &lt; j+len[nb1]; i++) {
      for (; i &lt; sig_len_in &amp;&amp; i &lt; j+128; i++) { // FIXME; # 128 could be tuned better?
        if (max1 &lt; sig_in[i]) max1 = sig_in[i];
        dd1 = max1 - min1;
        if (min1 &gt; sig_in[i]) dd1 = max1 - sig_in[i];
        if (dd1 &gt; mask[nb1]) break;
        if (min1 &gt; sig_in[i]) min1 = sig_in[i];
        nw++;
      }
    } else {                      // use difference values
      nb1 = 99;
      while (max2 - min2 &gt; mask[nb2]) nb2++;
      //for (; i &lt; sig_len_in &amp;&amp; i &lt; j+len[nb1]; i++) {
      for (; i &lt; sig_len_in &amp;&amp; i &lt; j+128; i++) { // FIXME; # 128 could be tuned better?
        ds = sig_in[i] - sig_in[i-1];
        if (max2 &lt; ds) max2 = ds;
        dd2 = max2 - min2;
        if (min2 &gt; ds) dd2 = max2 - ds;
        if (dd2 &gt; mask[nb2]) break;
        if (min2 &gt; ds) min2 = ds;
        nw++;
      }
    }

    if (bp &gt; 0) iso++;
    /*  -----  do actual compression  -----  */
    sig_out[iso++] = nw;  // compressed signal data, first byte = # samples
    bp = 0;               // bit pointer
    if (nb1 &lt;= nb2) {
      /*  -----  encode absolute values  -----  */
      sig_out[iso++] = nb1;                    // # bits used for encoding
      sig_out[iso++] = (unsigned short) min1;  // min value used for encoding
      for (i = iso; i &lt;= iso + nw*nb1/16; i++) sig_out[i] = 0;
      for (i = j; i &lt; j + nw; i++) {
        dd[0] = sig_in[i] - min1;              // value to encode
        dd[0] = dd[0] &lt;&lt; (32 - bp - nb1);
        sig_out[iso] |= db[1];
        bp += nb1;
        if (bp &gt; 15) {
          sig_out[++iso] = db[0];
          bp -= 16;
        }
      }

    } else {
      /*  -----  encode derivative / difference values  -----  */
      sig_out[iso++] = nb2 + 32;  // # bits used for encoding, plus flag
      sig_out[iso++] = (unsigned short) sig_in[j];  // starting signal value
      sig_out[iso++] = (unsigned short) min2;       // min value used for encoding
      for (i = iso; i &lt;= iso + nw*nb2/16; i++) sig_out[i] = 0;
      for (i = j+1; i &lt; j + nw; i++) {
        dd[0] = sig_in[i] - sig_in[i-1] - min2;     // value to encode
        dd[0]= dd[0] &lt;&lt; (32 - bp - nb2);
        sig_out[iso] |= db[1];
        bp += nb2;
        if (bp &gt; 15) {
          sig_out[++iso] = db[0];
          bp -= 16;
        }
      }
    }
    j += nw;
  }

  if (bp &gt; 0) iso++;
  if (iso%2) iso++;     // make sure iso is even for 4-byte padding
  return iso;           // number of shorts in compressed signal data

} /* compress_signal */


int decompress_signal(unsigned short *sig_in, short *sig_out, int sig_len_in) {

  int   i, j, min, nb, isi, iso, nw, bp, siglen;
  unsigned short db[2];
  unsigned int   *dd = (unsigned int *) db;
  static unsigned short mask[17] = {0, 1,3,7,15, 31,63,127,255,
                                    511,1023,2047,4095, 8191,16383,32767,65535};

  /* ------------ do decompression of signal ------------ */
  j = isi = iso = bp = 0;
  siglen = (short) sig_in[isi++];  // signal length
  //printf(&quot;&lt;&lt;&lt; siglen = %d\n&quot;, siglen);
  for (i=0; i&lt;2048; i++) sig_out[i] = 0;
  while (isi &lt; sig_len_in &amp;&amp; iso &lt; siglen) {
    if (bp &gt; 0) isi++;
    bp = 0;              // bit pointer
    nw = sig_in[isi++];  // number of samples encoded in this chunk
    nb = sig_in[isi++];  // number of bits used in compression

    if (nb &lt; 32) {
      /*  -----  decode absolute values  -----  */
      min = (short) sig_in[isi++];  // min value used for encoding
      db[0] = sig_in[isi];
      for (i = 0; i &lt; nw &amp;&amp; iso &lt; siglen; i++) {
        if (bp+nb &gt; 15) {
          bp -= 16;
          db[1] = sig_in[isi++];
          db[0] = sig_in[isi];
          dd[0] = dd[0] &lt;&lt; (bp+nb);
        } else {
          dd[0] = dd[0] &lt;&lt; nb;
        }
        sig_out[iso++] = (db[1] &amp; mask[nb]) + min;
        bp += nb;
      }

    } else {
      nb -= 32;
      /*  -----  decode derivative / difference values  -----  */
      sig_out[iso++] = (short) sig_in[isi++];  // starting signal value
      min = (short) sig_in[isi++];             // min value used for encoding
      db[0] = sig_in[isi];
      for (i = 1; i &lt; nw &amp;&amp; iso &lt; siglen; i++) {
        if (bp+nb &gt; 15) {
          bp -= 16;
          db[1] = sig_in[isi++];
          db[0] = sig_in[isi];
          dd[0] = dd[0] &lt;&lt; (bp+nb);
        } else {
          dd[0] = dd[0] &lt;&lt; nb;
        }
        sig_out[iso] = (db[1] &amp; mask[nb]) + min + sig_out[iso-1]; iso++;
        bp += nb;
      }
    }
    j += nw;
  }

  if (siglen != iso) {
    printf(&quot;ERROR in decompress_signal: iso (%d ) != siglen (%d)!\n&quot;,
           iso, siglen);
  }
  return siglen;       // number of shorts in decompressed signal data

} /* decompress_signal */</code></pre><footer><hr/><a class="previous" href="../hdf5/"><span class="direction">Previous</span><span class="title">HDF5</span></a><a class="next" href="../daq_data/"><span class="direction">Next</span><span class="title">DAQ Data</span></a></footer></article></body></html>
